#include "Task.hpp"
#include <typelib/registry.hh>
#include <rtt/rtt-config.h>
#include <utilmm/configfile/pkgconfig.hh>
#include <utilmm/stringtools.hh>
#include <typelib/pluginmanager.hh>
#include <rtt/base/PortInterface.hpp>
#include <rtt/types/Types.hpp>
#include <rtt/typelib/TypelibMarshallerBase.hpp>

#include <rtt/base/InputPortInterface.hpp>

using namespace std;
using base::Time;
using RTT::types::TypeInfo;
using RTT::log;
using RTT::endlog;
using RTT::Error;
using RTT::Info;

namespace  port_proxy
{

struct Task::ConnectionDescription
{
    std::string name;
    std::string type_name;

    Typelib::Registry* registry;
    orogen_transports::TypelibMarshallerBase::Handle* marshalling_handle;
    RTT::base::DataSourceBase::shared_ptr sample;

    // The port that should be proxied from
    RTT::base::InputPortInterface* read_port;
    // The port that should be written to
    RTT::base::OutputPortInterface* write_port;

    // Periodicity of retrieving the info
    // set from ((TaskContent*) this)->getActivity()->getPeriod()
    unsigned int period_max_count;

    // Allow activation of the reader based on subsampling rate
    // from the main periodicty
    unsigned int period_counter;
};

Task::Task(std::string const& name, TaskCore::TaskState initial_state)
    : TaskBase(name, initial_state)
    , m_registry(0)
{
    loadRegistry();

    // Register a fake protocol object to be able to marshal samples
    // "the typelib way"
}

Task::Task(std::string const& name, RTT::ExecutionEngine* engine, TaskCore::TaskState initial_state)
    : TaskBase(name, engine, initial_state)
    , m_registry(0)
{
    loadRegistry();
}



Task::~Task()
{
    delete m_registry;
}

bool Task::startHook()
{
    return true;
}

void Task::updateHook()
{
    Time stamp = Time::now();
    for (Connections::iterator it = root.begin(); it != root.end(); ++it)
    {
        // Check on periodicity 
        if(it->period_counter++ >= it->period_max_count)
        {
            it->period_counter = 0;
            if(it->read_port->read(it->sample, false) == RTT::NewData)
            {
                it->write_port->write(it->sample);
            }
        }
    }
}

void Task::stopHook()
{
}

// report a specific connection.
bool Task::createProxyConnection(const std::string& name, const std::string& type_name, double periodicity) {

    std::string input_port_name("in_" + name);
    std::string output_port_name("out_" + name);

    RTT::base::PortInterface *pi = ports()->getPort(input_port_name);
    if(pi) // we are already having a connection of the given name
    {
        log(Info) << "connection " << name << " is already registered" << endlog();
        // Since the connection already exists, everything is good?! 
        // so could be true here as well
        return false;
    }

    RTT::types::TypeInfoRepository::shared_ptr ti = RTT::types::TypeInfoRepository::Instance();
    RTT::types::TypeInfo* type = ti->type(type_name);
    if (! type)
    {
	cerr << "cannot find " << type_name << " in the type info repository" << endl;
	return false;
    }
    
    RTT::base::InputPortInterface *in_port = type->inputPort(input_port_name);
    RTT::base::OutputPortInterface *out_port = type->outputPort(output_port_name); 
    return addProxyConnection(in_port, out_port, name, periodicity);
}

bool Task::addProxyConnection(RTT::base::InputPortInterface* in_port, RTT::base::OutputPortInterface* out_port, std::string const& name, double periodicity)
{
    TypeInfo const* type = in_port->getTypeInfo();
    orogen_transports::TypelibMarshallerBase* transport =
        dynamic_cast<orogen_transports::TypelibMarshallerBase*>(type->getProtocol(orogen_transports::TYPELIB_MARSHALLER_ID));
    if (! transport)
    {
        log(Error) << "cannot handle ports of type " << type->getTypeName() << " as no typekit generated by orogen defines it" << endlog();
        return false;
    }

    if (! m_registry->has(transport->getMarshallingType()))
    {
        log(Error) << "cannot handle ports of type " << type->getTypeName() << " as I can't find a typekit Typelib registry that defines it" << endlog();
        return false;
    }

    // Add ports to the current task
    ports()->addPort(in_port->getName(), *in_port);
    ports()->addPort(out_port->getName(), *out_port);

    try {
        ConnectionDescription connection;
        connection.name         = name;
        connection.type_name    = transport->getMarshallingType();
        connection.read_port    = in_port;
        connection.write_port   = out_port; 

        connection.registry     = m_registry->minimal(connection.type_name);
        connection.marshalling_handle = transport->createSample();
        connection.sample = transport->getDataSource(connection.marshalling_handle);
        
        double taskPeriodicity = this->getActivity()->getPeriod();
        if(periodicity < taskPeriodicity)
        {
            log(Error) << "requested connection periodicity is lower than the core component's one. Either adapt the periodicity of the core component or lower your requirements. " << endlog();
        }
           
        // Currently assuming the core periodicity will be low enough 
        // to support a resolution of 0.1 s
        connection.period_max_count = periodicity / taskPeriodicity;
        connection.period_counter = 0;

        log(Info) << "adding connection period count for '" << name << "' to " << connection.period_max_count << " while having a base period of " << taskPeriodicity << "s" << endlog();

        root.push_back(connection);
    } catch ( RTT::internal::bad_assignment& ba ) {
        return false;
    }
    return true;
}

bool Task::closeProxyConnection(std::string const& name)
{
    for (Connections::iterator it = root.begin(); it != root.end(); ++it)
    {
        if ( it->read_port->getName() == name )
        {
            ports()->removePort(it->read_port->getName());
            ports()->removePort(it->write_port->getName());

            delete it->read_port;
            delete it->write_port;
            delete it->registry;
            root.erase(it);
            return true;
        }
    }

    return false;
}

bool Task::closeAllProxyConnection()
{
    std::vector<std::string> names;
    std::vector<std::string>::iterator names_it;

    for (Connections::iterator it = root.begin(); it != root.end(); ++it)
    {
        names.push_back(it->name);
    }
    
    for(names_it = names.begin(); names_it != names.end(); ++names_it)
    {
        closeProxyConnection(*names_it);
    }

    return true;
}

#define TASK_LIBRARY_NAME_PATTERN_aux0(target) #target
#define TASK_LIBRARY_NAME_PATTERN_aux(target) "-typekit-" TASK_LIBRARY_NAME_PATTERN_aux0(target)
#define TASK_LIBRARY_NAME_PATTERN TASK_LIBRARY_NAME_PATTERN_aux(OROCOS_TARGET)
void Task::loadRegistry()
{
    string const pattern = TASK_LIBRARY_NAME_PATTERN;
    delete m_registry;
    m_registry = new Typelib::Registry;

    // List all known toolkits and load the ones that have a .tlb file defined.
    list<string> packages = utilmm::pkgconfig::packages();
    for (list<string>::const_iterator it = packages.begin(); it != packages.end(); ++it)
    {
        if (it->size() > pattern.size() && string(*it, it->size() - pattern.size()) == pattern)
        {
            utilmm::pkgconfig pkg(*it);
            string tlb = pkg.get("type_registry");
            if (!tlb.empty())
            {
                try {
                    auto_ptr<Typelib::Registry> registry( Typelib::PluginManager::load("tlb", tlb) );
                    m_registry->merge(*registry.get());
                    log(Info) << "loaded " << tlb << " in the data logger registry" << endlog();
                }
                catch(...)
                {
                    log(Error) << "cannot load registry file " << tlb << endlog();
                }
            }
        }
    }
}

} // end of namespace

